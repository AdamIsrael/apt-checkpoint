#!/usr/bin/python
import apt_pkg						# Our interface to local packages
import pickle						# Object serialization
import os, sys, commands
from datetime import datetime		
import time, locale
from optparse import OptionParser	# To handle command line args
import gzip 						# To read Packages.gz
import httplib, urlparse			# To download files
import tempfile						# To handle temp files

# Configuration Settings
CACHE = '/var/cache/apt/checkpoint'
ARCHIVE = '/var/cache/apt/archives'
SNAPSHOT = 'http://snapshot.debian.net/archive/'

# Internal objects
cache = None
packages = None
parser = None
options = None

class PackagesGz:
	Packages = []
	def __init__(self, file):
		self.Packages = self.parse(string.join(gzip.open(file)))
		pass
	def parse(self,source):
		# Parse the Packages.gz source into a hash table
		# Packages are seperated by \n\n
		# Each package record is <key>: <value>
		Packages = []
		Package = {}
		record = ''
		# Buffer one record at a time, then parse it
		for line in source.split('\n'):
			if len(line.strip()) == 0:
				# We have a `record`, with pairs of fields (key, value)
				# `key` is start of line up to the first colon `:`
				# `value` is everything from the `:` until the next line
				# containing a `:` (multi-line values)
				key = ''
				value = ''
				while(len(record) > 0):
					if len(key) == 0:
						idx = record.find(':')
						if idx >= 0:
							key = record[0:idx]
							record = record[idx+1:]
					else:
						if len(value) > 0:
							if (record.find(':') >= 0 and record.find(':') < record.find('\n')):
								# done with this key:value pair
								Package[key] = value
								key = ''
								value = ''
								continue
						idx = record.find('\n')
						if idx >= 0:
							value += record[0:idx]
							record = record[idx+1:]
							if len(record) == 0:
								# Last key:value pair of record
								Package[key] = value
								key = ''
								value = ''
								Packages.append(Package)
								Package = {}
				record = ''
				pass
			else:
				record += line + '\n'
		return Packages


		
class Checkpoint:
	Description = None
	Packages = {}
	def __init__(self):
		pass

class Package:
	Version = None
	Name = None
	State = None
	FileName = None
	def __init__(self):
		pass

def initialize():
	global cache, packages
	apt_pkg.init()
	cache = apt_pkg.GetCache()
	packages = cache.Packages

	if not os.path.exists(CACHE):
		os.mkdir(CACHE)

def HttpDownload(url):
	data = ''
	u = urlparse.urlparse(url)	
	conn = httplib.HTTPConnection(u[1])
	conn.request('GET', u[2])
	resp = conn.getresponse()
	if resp.Status == 200:
		data = resp.read()
	return data
	
# Get a list of available checkpoints in the CACHE
def getCheckpoints():
	checkpoints = os.listdir(CACHE)
	return checkpoints

def diff():
	global packages
	initialize()
	checkpoints = getCheckpoints()

	# default to the most recent checkpoint
	checkpoint = pickle.load(open(CACHE + os.sep + checkpoints[len(checkpoints)-1]))
	for package in packages:
		versions = package.VersionList
		if package.Name in checkpoint.Packages and package.CurrentState != 6:
			print "Package found in checkpoint but not installed: ", package.Name
		elif package.CurrentState == 6 and package.Name not in checkpoint.Packages:
			print "Package not found in checkpoint but installed: ", package.Name
		elif package.CurrentState == 6 and package.Name in checkpoint.Packages:
			v = apt_pkg.VersionCompare(package.CurrentVer.VerStr, checkpoint.Packages[package.Name].Version)
			if v == 1:
				print "%s: Version differs(%s -> %s)" % (package.Name, checkpoint.Packages[package.Name].Version, versions[0].VerStr)	
	pass


def create():
	global cache
	initialize()
	cp = Checkpoint()
	cp.Packages = {}
	records = apt_pkg.GetPkgRecords(cache)
	for package in packages:
		#versions = package.VersionList
		#if not versions:
		#	continue
		if package.CurrentVer and package.CurrentState == 6:
			#records.Lookup(versions[0].FileList[0])
			records.Lookup(package.CurrentVer.FileList[0])
			p = Package()
			p.Name = package.Name
			p.Version = package.CurrentVer.VerStr
			p.State = package.CurrentState
			p.FileName = records.FileName
			cp.Packages[package.Name] = p
	if cp.Packages:
		cp.Description = options.description
		print len(cp.Packages), "installed packages"
		chkpt = CACHE + os.sep + time.strftime('%Y-%m-%d-%H-%M') + '.bin'
		print chkpt
		pickle.dump(cp, open(chkpt, 'w'))

	pass
def rollback():
	global packages
	initialize()
	checkpoints = getCheckpoints()
	install = False
	remove = False
	checkpoint = pickle.load(open(CACHE + os.sep + checkpoints[len(checkpoints)-1]))
	print len(checkpoint.Packages), "packages"
	for package in packages:
		install = False
		remove = False
		if package.Name in checkpoint.Packages:
			v = apt_pkg.VersionCompare(package.CurrentVer.VerStr, checkpoint.Packages[package.Name].Version)
			if v > 0:
				if package.CurrentState == 6:
					print "Downgrade package", package.Name
					install = True
					remove = True
				else:
					install = False
					remove = True
					print "Remove package", package.Name
		if (install or remove) and package.Name in checkpoint.Packages:
			pkg = checkpoint.Packages[package.Name]
			print pkg
			deb = ''
			if len(pkg.FileName) > 0:
				print pkg.FileName
				# First, check to see if the package is in the local archive
				deb = ARCHIVE + os.sep + pkg.FileName.split('/')[-1:][0]
				if(not os.path.exists(deb)):
					deb = ''
			# Next, check for apt-mirror
			# Last, download the needed packages from snapshot.debian.net
			# Download Packages.gz
			if len(deb) > 0:
				# Remove the current package
				if remove:
					print "Remove:", pkg.Name
					#print commands.getoutput('dpkg --force-depends,downgrade,depends-version -r %s' % (pkg.Name))
				# Install the checkpointed package
				if install and len(deb) > 0:
					print "Install:", pkg.Name
					#print commands.getoutput('dpkg -i %s' % (deb))
		pass
def view():
	checkpoints = getCheckpoints()
	count = 1
	for checkpoint in checkpoints:
		chk = pickle.load(open(CACHE + os.sep + checkpoint))
		t = time.strptime(checkpoint.split('.')[0], '%Y-%m-%d-%H-%M')
		print '[' + str(count) + '] ',time.strftime(locale.nl_langinfo(locale.D_T_FMT), t), '[' + chk.Description + ']'
		count += 1
	pass

def Help():
	usage = """	%prog [options] command
	%prog [options] create
	%prog [options] diff
	%prog [options] rollback
	%prog [options] view
	
apt-checkpoint is a simple command line interface for saving and
restoring package checkpoints.  The most frequently used commands
are create, diff, and rollback.

commands:
    create - Create a checkpoint of the current system
    diff - View the difference between the current and checkpointed system
    rollback - Restore the system to it's previously saved state
    view - View saved checkpoints
	"""
	return usage


def CachePackage(pkg):
	# Download a package and cache it locally
	
	# Get Releases.gz from snapshot.debian.net

	# Find package record matching this package

	# Download package to local archive

	
	pass
	
def main():	
	global parser, options
	parser = OptionParser(Help())
	parser.add_option("-d", "--description",
					dest="description",
					help="Checkpoint description")
	parser.add_option("-c", "--clean",
		type="int", dest="clean",
		help="Erase checkpoints more than n days old")
		
	(options, args) = parser.parse_args()
	if len(sys.argv) == 1:
		parser.print_help()
		return 0
		
	command = sys.argv[1]
	if command in ['create', 'diff', 'rollback', 'view']:
		exec(command + "()")
		pass
	else:
		parser.print_help()
	return 0

if __name__ == "__main__":
	main()



